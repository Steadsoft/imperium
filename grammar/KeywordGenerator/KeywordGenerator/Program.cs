using System.Text;
using System.Text.Json;

namespace KeywordGenerator
{
    internal class Program
    {
        static void Main(string[] args)
        {
            // load the dictionary.

            JsonSerializerOptions options = new JsonSerializerOptions() { ReadCommentHandling = JsonCommentHandling.Skip };

            var language_dictionary = JsonSerializer.Deserialize<Dictionary<string, Dictionary<string, string>>>(File.ReadAllText(@"..\..\..\..\..\antlr\imperium.keywords.json"), options);//.ToDictionary(x => x.Key, x => x.Value.ToDictionary(x => x.Value, x => x.Key));

            var expected = language_dictionary["en"].Count();

            Console.WriteLine($"Language 'en' contains {expected} entries.");

            foreach (var dict in language_dictionary.Where(ld => ld.Key != "en"))
            {
                if (dict.Value.Count() < expected)
                    Console.WriteLine($"Language '{dict.Key}' contains too few entries ({dict.Value.Count()}).");

                if (dict.Value.Count() > expected)
                    Console.WriteLine($"Language '{dict.Key}' contains too many entries ({dict.Value.Count()}).");

                if (dict.Value.Count() == expected)
                    Console.WriteLine($"Language '{dict.Key}' contains the correct number of entries ({expected}).");


            }

            // ensure each language has unique keywords, do not allow the same terms to appear in several definitions for any given language

            bool dupes_present = false;

            foreach (var language in language_dictionary.OrderBy(e => e.Key))
            {
                var dupes = language.Value.Values.SelectMany(s => s.Split(',')).Select(s => s.Trim()).GroupBy(s => s).Where(g => g.Count() > 1);

                if (dupes.Any())
                {
                    foreach (var dupe in dupes)
                    {
                        Console.WriteLine($"The language '{language.Key}' contains mulitple uses of the target keyword '{dupe.Key}'");
                    }

                    dupes_present = true;
                }
            }

            if ( dupes_present )
            {
                Console.WriteLine("Keyword file creation aborted.");
                return;
            }

            Dictionary<string,string> output = new Dictionary<string,string>();

            foreach (var language in language_dictionary.OrderBy(e => e.Key))
            {
                foreach (var keyword_pair in language_dictionary[language.Key])
                {
                    if (!output.ContainsKey(keyword_pair.Key))
                    {
                        output[keyword_pair.Key] = $"{keyword_pair.Key.ToUpper()}: [KeywordLanguageCode == !{language.Key}!]? ({ExtractMultiples(keyword_pair.Value)}) | ".Replace('[','{').Replace(']', '}').Replace('!', '"');
                    }
                    else
                    {
                        output[keyword_pair.Key] = output[keyword_pair.Key] + $"[KeywordLanguageCode == !{language.Key}!]? ({ExtractMultiples(keyword_pair.Value)}) | ".Replace('[','{').Replace(']', '}').Replace('!', '"');
                    }
                }
            }

            foreach (var entry in output)
            {
                output[entry.Key] = entry.Value.Trim(' ').Trim('|') + ";";            
            }




            var file = File.CreateText(@"..\..\..\..\..\antlr\ImperiumKeywords.txt");

            file.WriteLine($"/* These Antlr4 keyword token definitions were generated by a utility on {DateTime.Now.ToShortDateString()} at {DateTime.Now.ToShortTimeString()} */");
            file.WriteLine();

            foreach (var kv in output)
            {
                file.WriteLine(kv.Value);
            }

            file.WriteLine() ;
            file.WriteLine("/* End of generated Antlr4 keyword token definitions. */");

            file.Close(); ;
        }

        // If a keyword def include a full and an abbreviation or alias, pull them out here
        private static string ExtractMultiples(string input)
        {

            if (input.Contains(',') == false)
                return $"'{input}'";

            StringBuilder builder = new StringBuilder();

            var parts = input.Split(',');

            foreach (var part in parts)

            {
                builder.Append($"'{part.TrimStart().TrimEnd()}' | ");
            }

            return builder.ToString().Trim().Trim('|').Trim();

        }
    }
}